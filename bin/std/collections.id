# Author: SplittyDev (github.com/splittydev)

/* TODO: Change to trait Iterable
interface IEnumerable {
    func __iter__ (self);
}
*/

# TODO: Change to contract Collection
interface ICollection {
    func clear (self)
    func count (self)
    func empty (self)
    func add (self, item)
    func remove (self, item)
    func contains (self, item)
}

class Array : ICollection {

    /* Constructor
     * @param **Object kwargs Optional arguments
     * @optional Int capacity The capacity
     * @optional List items The elements to initialize the Array with
     * @optional Int prealloc The amount of space to be preallocated
     */
    func Array (self, **kwargs) {
        self.list = []
        self.length = 0
        self.capacity = -1
        foreach (key in kwargs) {
            match (key) {
                case "capacity" => self.capacity = typecast (Int, kwargs [key])
                case "items" => (lambda () {
                    foreach (i in typecast (List, kwargs [key]))
                        self.add (i)
                    }) ()
                case "prealloc" => (lambda () {
                    maxfill = typecast (Int, kwargs [key])
                    if (maxfill > self.capacity)
                        raise Exception ("Preallocating overflows the capacity.")
                    for (i = 0; i < maxfill; i += 1)
                        self.add (null)
                    }) ()
            }
        }
    }

    /* Clears the collection
     * @return null
     */
    func clear (self) {
        self.list.clear ()
        self.length = 0
    }

    /* Counts the elements in the collection
     * @return Int The element count
     */
    func count (self) {
        return self.length
    }

    /* Determines whether the collection is empty
     * @return Bool Whether the collection is empty
     */
    func empty (self) {
        return self.length == 0
    }

    /* Adds an element to the collection
     * @param Object item The element to be added
     * @return null
     */
    func add (self, item) {
        if (self.length == self.capacity)
            raise Exception ("Maximum capacity reached.")
        self.list.add (item)
        self.length += 1
    }

    /* Removes an element from the collection
     * @param Object item The element to be removed
     * @return null
     */
    func remove (self, item) {
        i = 0
        foreach (x in self.list) {
            if (x == item) {
                self.list.removeAt (i)
                self.length -= 1
                return null
            }
            i += 1
        }
        raise Exception ("The item is not an element of the collection.")
    }

    /* Removes the specific element from the collection
     * @param Int index The index of the element to be removed
     * @return null
     */
    func removeAt (self, index) {
        self.list.removeAt (typecast (Int, index))
        self.length -= 1
    }

    /* Determines whether something is an element of the collection
     * @param Object item The item
     * @return bool Whether the specified item is an element of the collection
     */
    func contains (self, item) {
        return self.list.contains (item)
    }

    /* Gets the length
     * @return Int The length
     */
    func __len__ (self) {
        return self.count ()
    }

    /* Gets the string representation
     * @return Str The string representation
     */
    func __str__ (self) {
        return self.__repr__ ()
    }

    /* Gets the string representation
     * @return Str The string representation
     */
    func __repr__ (self) {
        return repr (self.list)
    }

    /* Gets the item at the specified index
     * @param Int i The index
     * @return Object The item at the specified index
     */
    func __getIndex__ (self, i) {
        return self.list [i]
    }

    /* Sets the item at the specified index
     * @param Int i The index
     * @param Object item The item
     * @return null
     */
    func __setIndex__ (self, i, item) {
        self.list [i] = item
    }
    
    /* Gets the iterator
     * @yield Object The items
     */
    func __iter__ (self) {
        for (i = 0; i < self.length; i += 1)
            yield self.list [i]
    }

    /* Fills an array with zeros
     * @param Array arr The array to be filled with zeros
     * @return Array The array
     */
    func zeroFill (arr) {
        typecast (Array, arr)
        for (i = 0; i < arr.length; i += 1)
            arr [i] = 0
        return arr
    }

    /* Fills an array with an object
     * @param Array arr The array to be filled with the specified object
     * @param Object filler The object that the array is to be filled with
     * @return Array The array
     */
    func fill (arr, filler) {
        typecast (Array, arr)
        for (i = 0; i < arr.length; i += 1)
            arr [i] = filler
        return arr
    }
}

class Set : ICollection {

    /* Constructor
     * @param **Object kwargs Optional arguments
     * @optional Int capacity The capacity
     * @optional List items The elements to initialize the Set with
     */
    func Set (self, **kwargs) {
        self.list = []
        self.cardinality = 0
        self.capacity = -1
        foreach (key in kwargs) {
            match (key) {
                case "capacity" => self.capacity = typecast (Int, kwargs [key])
                case "items" => (lambda () {
                    foreach (i in typecast (List, kwargs [key]))
                        self.add (i)
                }) ()
            }
        }
    }

    /* Clears the collection
     * @return null
     */
    func clear (self) {
        self.list.clear ()
        self.cardinality = 0
    }

    /* Counts the elements in the collection
     * @return Int The element count
     */
    func count (self) {
        return self.cardinality
    }

    /* Determines whether the collection is empty
     * @return Bool Whether the collection is empty
     */
    func empty (self) {
        return self.cardinality == 0
    }

    /* Adds an element to the set
     * @param Object item The element to be added
     * @return null
     */
    func add (self, item) {
        if (self.cardinality == self.capacity)
            raise Exception ("Maximum capacity reached.")
        if (self.contains (item))
            return null
        self.list.add (item)
        self.cardinality += 1
    }

    /* Removes an element from the set
     * @param Object item The element to be removed
     * @return null
     */
    func remove (self, item) {
        i = 0
        foreach (x in self.list) {
            if (x == item) {
                self.list.removeAt (i)
                self.cardinality -= 1
                return null
            }
            i += 1
        }
        raise Exception ("The item is not an element of the set.")
    }

    /* Returns the union of this and another set
     * @param Set other The other set
     * @return Set A set containing the union of this and another set
     */
    func union (self, other) {
        typecast (Set, other)
        set = Set (items: other.list)
        foreach (item in self.list) {
            if (!other.contains (item))
                set.add (item)
        }
        return set
    }

    /* Returns the intersection of this and another set
     * @param Set other The other set
     * @return Set A set containing the intersection of this and the other set
     */
    func intersection (self, other) {
        typecast (Set, other)
        set = Set ()
        foreach (item in self.list) {
            if (other.contains (item))
                set.add (item)
        }
        return set
    }

    /* Returns the difference of this and another set
     * @param Set other The other set
     * @return Set A set containing the difference of this and the other set
     */
    func difference (self, other) {
        typecast (Set, other)
        set = Set ()
        foreach (item in self.list) {
            if (!other.contains (item))
                set.add (item)
        }
        return set
    }

    /* Determines whether this is a superset of another set
     * @param Set other The other set
     * @return Bool Whether this is a superset of the other set
     */
    func superset (self, other) {
        typecast (Set, other)
        i = 0
        foreach (item in self.list) {
            if (other.contains (item))
                i += 1
        }
        return other.cardinality == i
    }

    /* Determines whether this is a subset of another set
     * @param Set other The other set
     * @return Bool Whether this is a subset of the other set
     */
    func subset (self, other) {
        typecast (Set, other)
        i = 0
        foreach (item in other.list) {
            if (self.contains (item))
                i += 1
        }
        return self.cardinality == i
    }

    /* Determines whether something is an element of the set
     * @param Object item The item
     * @return bool Whether the specified item is an element of the array
     */
    func contains (self, item) {
        return self.list.contains (item)
    }

    /* Gets the length
     * @return Int The length
     */
    func __len__ (self) {
        return self.count ()
    }

    /* Gets the string representation
     * @return Str The string representation
     */
    func __str__ (self) {
        return self.__repr__ ()
    }

    /* Gets the string representation
     * @return Str The string representation
     */
    func __repr__ (self) {
        return repr (self.list)
    }

    /* Gets the item at the specified index
     * @param Int i The index
     * @return Object The item at the specified index
     */
    func __getIndex__ (self, i) {
        return self.list [i]
    }
    
    /* Gets the iterator
     * @yield Object The items
     */
    func __iter__ (self) {
        for (i = 0; i < self.cardinality; i += 1)
            yield self.list [i]
    }
    
    /* Creates a new set from a list
     * @param List lst The items
     * @return Set A set contaning the elements of the specified lists
     */
    func create (lst) {
        return Set (items: typecast (List, lst))
    }

    /* Returns the union of two sets
     * @param Set a The first set
     * @param Set b The second set
     * @return Set A set containing the union of the two sets
     */
    func unionOf (a, b) {
        return typecast (Set, a).union (b)
    }

    /* Returns the intersection of two sets
     * @param Set a The first set
     * @param Set b The second set
     * @return Set A set containing the intersection of the two sets
     */
    func intersectionOf (a, b) {
        return typecast (Set, a).intersection (b)
    }

    /* Returns the difference of two sets
     * @param Set a The first set
     * @param Set b The second set
     * @return Set A set contaning the difference of the two sets
     */
    func differenceOf (a, b) {
        return typecast (Set, a).difference (b)
    }

    /* Determines whether a set is a superset of another set
     * @param Set a The first set
     * @param Set b The second set
     * @return Bool Whether the first set is a superset of the second set
     */
    func supersetOf (a, b) {
        return typecast (Set, a).superset (b)
    }

    /* Determines whether a set is a subset of another set
     * @param Set a The first set
     * @param Set b The second set
     * @return Bool Whether the first set is a subset of the second set
     */
    func subsetOf (a, b) {
        return typecast (Set, a).subset (b)
    }
}

class GenericSet : Set, ICollection {

    /* Constructor
     * @param **Object kwargs Optional arguments
     * @optional Type T
     * @optional Int capacity
     * @optional List items
     */
    func GenericSet (self, **kwargs) {
        super (kwargs);
        self.type = null
        foreach (key in kwargs) {
            print (key)
            current = kwargs [key]
            match (key) {
                case "T" => self.type = current
            }
        }
    }

    /* Adds an element to the set
     * @param Object item The element to be added
     * @return null
     */
    func add (self, item) {
        # TODO: Replace with Null type-check
        if (self.type.__type__ == null.__type__) {
            self.type = item.__type__
        }
        typecast (self.type, item)
        self.__super__.add (item)
    }

    /* Removes an element from the set
     * @param Object item The element to be removed
     * @return null
     */
    func remove (self, item) {
        typecast (self.type, item)
        self.__super__.remove (item)
    }
}

class Stack : ICollection {

    /* Constructor
     * @param **Object kwargs Optional arguments
     * @optional Int capacity
     * @optional List items
     */
    func Stack (self, **kwargs) {
        self.list = []
        self.top = 0
        self.capacity = -1
        foreach (key in kwargs) {
            match (key) {
                case "capacity" => self.capacity = typecast (Int, kwargs [key])
                case "items" => (lambda () {
                    foreach (i in typecast (List, kwargs [key]))
                        self.push (i)
                }) ()
            }
        }
    }

    /* Clears the collection
     * @return null
     */
    func clear (self) {
        self.list.clear ()
        self.top = 0
    }

    /* Counts the elements in the collection
     * @return Int The element count
     */
    func count (self) {
        return self.top
    }

    /* Determines whether the collection is empty
     * @return Bool Whether the collection is empty
     */
    func empty (self) {
        return self.top == 0
    }

    /* Adds an element to the collection
     * @param Object item The element to be added
     * @return null
     */
    func add (self, item) {
        raise Exception ("Use Stack.push instead!")
    }

    /* Pushes an item onto the stack
     * @param Object item The item to be pushed onto the stack
     * @return null
     */
    func push (self, item) {
        if (self.top == self.capacity)
            raise Exception ("Maximum capacity reached.")
        self.list.add (item)
        self.top += 1
    }

    /* Pops an item from the stack
     * @return Object The item that was popped from the stack
     */
    func pop (self) {
        if (self.top == 0)
            raise Exception ("There are no elements on the stack.")
        self.top -= 1
        item = self.list [self.top]
        self.list.removeAt (self.top)
        return item
    }

    /* Removes an element from the collection
     * @param Object item The element to be removed
     * @return null
     */
    func remove (self, item) {
        for (i = 0; i < self.top; i += 1) {
            if (self [i] == item) {
                self.list.removeAt (self.top - i - 1)
                self.top -= 1
                return null
            }
        }
    }

    /* Determines whether something is an element of the collection
     * @param Object item The item
     * @return bool Whether the specified item is an element of the collection
     */
    func contains (self, item) {
        return self.list.contains (item)
    }

    /* Removes an element from the collection
     * @param Object item The element to be removed
     * @return null
     */
    func removeAt (self, index) {
        self.list.removeAt (self.top - typecast (Int, index) - 1)
        self.top -= 1
    }

    /* Gets the length
     * @return Int The length
     */
    func __len__ (self) {
        return self.count ()
    }

    /* Gets the string representation
     * @return Str The string representation
     */
    func __str__ (self) {
        return self.__repr__ ()
    }

    /* Gets the string representation
     * @return Str The string representation
     */
    func __repr__ (self) {
        return repr (self.list)
    }

    /* Gets the item at the specified index
     * @param Int i The index
     * @return Object The item at the specified index
     */
    func __getIndex__ (self, i) {
        return self.list [self.top - i - 1]
    }

    /* Sets the item at the specified index
     * @param Int i The index
     * @param Object item The item
     * @return null
     */
    func __setIndex__ (self, i, item) {
        self.list [self.top - i - 1] = item
    }
    
    /* Gets the iterator
     * @yield Object The items
     */
    func __iter__ (self) {
        for (i = 0; i < self.top; i += 1) {
            yield self [i]
        }
    }
}

class GenericStack : Stack, ICollection {

    /* Constructor
     * @param **Object kwargs Optional arguments
     * @optional Int capacity
     * @optional List items
     * @optional Type T The type
     */
    func GenericStack (self, **kwargs) {
        super (kwargs);
        self.type = null
        print (len (kwargs))
        foreach (key in kwargs) {
            current = kwargs [key]
            match (key) {
                case "T" => self.type = current
            }
        }
    }

    /* Pushes an item onto the stack
     * @param Object item The item to be pushed onto the stack
     * @return null
     */
    func push (self, item) {
        # TODO: Replace with Null type-check
        if (self.type.__type__ == null.__type__) {
            self.type = item.__type__
        }
        typecast (self.type, item)
        self.__super__.push (item)
    }

    /* Removes an element from the collection
     * @param Object item The element to be removed
     * @return null
     */
    func remove (self, item) {
        typecast (self.type, item)
        self.__super__.remove (item)
    }
}