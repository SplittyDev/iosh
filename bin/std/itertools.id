/**
 * Provides functions for iterating over items of any iterable
 * @module std/builtin
 * @author SplittyDev
 */

# <-- stdlib include guard -----------
try{if(__STDLIB);}
except{global __STDLIB=true}
try{if(!__STDLIB_ITERTOOLS)
global __STDLIB_ITERTOOLS=true}
except{global __STDLIB_ITERTOOLS=true}
# --- stdlib include guard ---------->

use Iterable from std.collections

/**
 * Chains multiple iterables to one
 * @param *iterators The iterables
 * @yield Object The items of the chain
 */
func chain (*iterables) {
    typecast (Iterable, iterables)
    for (iterator in iterables) {
        typecast (Iterable, iterator)
        for (item in iterator) {
            yield item
        }
    }
}

/**
 * Executes a function for every element of an iterator
 * @param Object iterator The iterator
 * @param Object The callback
 * @return null
 */
func each (iterator, callback) {
    typecast (Iterable, iterator)
    for (item in iterator) {
        callback (item)
    }
}

/**
 * Takes the first n elements
 * @param Object iterator The iterator
 * @param Int count The number of elements to take
 * @yield Object The elements
 */
func take (iterator, count) {
    typecast (Iterable, iterator)
    i = 0
    for (item in iterator) {
        if (i < count) {
            yield item
        }
        i += 1
    }
}

/**
 * Takes elements while a condition is true
 * @param Object iterator The iterator
 * @param Object callback The condition
 * @yield Object The elements
 */
func takewhile (iterator, callback) {
    typecast (Iterable, iterator)
    stop = false
    for (item in iterator) {
        if (!stop && !typecast (Bool, callback (item))) {
            stop = true
        }
        if (stop) {
            continue
        }
        yield item
    }
}

/**
 * Skips the first n elements
 * @param Object iterator The iterator
 * @param Int The number of elements to skip
 * @yield The remaining elements
 */
func skip (iterator, count) {
    typecast (Iterable, iterator)
    i = 0
    for (item in iterator) {
        if (i >= count) {
            yield item
        }
        i += 1
    }
}

/**
 * Skips elements while a condition is true
 * @param Object iterator The iterator
 * @param Object callback The condition
 * @yield Object The remaining elements
 */
func skipwhile (iterator, callback) {
    typecast (Iterable, iterator)
    _skip = true
    for (item in iterator) {
        if (_skip && !typecast (Bool, callback (item))) {
            _skip = false
        }
        if (_skip) {
            continue
        }
        yield item
    }
}

/**
 * Adds up all items of an iterable
 * @param Object iterable The iterable
 * @param **Object kwargs Optional arguments
 * @optional Object start The result to start with
 * @return Object The result
 */
func sum (iterable, **kwargs) {
    typecast (Iterable, iterable)
    result = 0
    for (key in kwargs) {
        match (key) {
            case "start" => result = kwargs [key]
        }
    }
    for (item in iterable) {
        result += item
    }
    return result
}

func zip (*iterables) {
    typecast (Iterable, iterables)
    result = []
    iteratorCount = len (iterables)
    iterators = []
    iteratorIndices = []
    iteratorCounts = []
    for (iterator in iterables) {
        typecast (Iterable, iterator)
        iterators.append (iterator)
        iteratorIndices.append (0)
        iteratorCounts.append (len (iterator))
    }
    while (true) {
        objs = []
        for (i = 0; i < iteratorCount; i += 1) {
            if (iteratorCounts [i] == iteratorIndices [i]) {
                return result
            }
            objs.append (iterators [i] [iteratorIndices [i]])
            iteratorIndices [i] += 1
        }
        result.append (Tuple (objs))
    }
}

/**
 * Reduces an iterable by iterating over it,
 * passing, for all items, the result of the previous item and the current item
 * to a function, whose result is then returned to the caller.
 * @param Object iterable The iterable
 * @param Object callback The callback
 * @param **Object kwargs Optional arguments
 * @optional Object start The result to start with
 * @return Object The result of the reduction
 */
func reduce (iterable, callback, **kwargs) {
    typecast (Iterable, iterable)
    # TODO: Use trait Callable/Invokable for callback
    result = 0
    for (key in kwargs) {
        match (key) {
            case "start" => result = kwargs [key]
        }
    }
    for (item in iterable) {
        result = callback (result, item)
    }
    return result
}

/**
 * Iterates through an iterable, passing each to a function.
 * If that functions returns true, the item is appended to a list,
 * which is then returned to the caller.
 * @param Object iterable The iterable
 * @param Object callback The callback
 * @return List The filtered items
 */
func filter (iterable, callback) {
    typecast (Iterable, iterable)
    # TODO: Use trait Callable/Invokable for callback
    for (item in iterable) {
        if (callback (item)) {
            yield item
        }
    }
}

/**
 * Iterates through an iterable, passing each to a function.
 * The return value of each function call is appended to a list,
 * which is then returned to the caller.
 * @param Object iterable The iterable
 * @param Object callback The callback
 * @return List The mapped items
 */
func map (iterable, callback) {
    typecast (Iterable, iterable)
    # TODO: Use trait Callable/Invokable for callback
    for (item in iterable) {
        yield callback (item)
    }
}