# Author: SplittyDev (github.com/splittydev)

# Chains multiply iterables to one
# @param *iterators The iterables
# @yield Object The items of the chain
func chain (*iterables) {
    for (iterator in iterables) {
        for (item in iterator) {
            yield item
        }
    }
}

# Executes a function for every element of an iterator
# @param Object iterator The iterator
# @param Object The callback
# @return null
func each (iterator, callback) {
    for (item in iterator) {
        callback (item)
    }
}

# Takes the first n elements
# @param Object iterator The iterator
# @param Int count The number of elements to take
# @yield Object The elements
func take (iterator, count) {
    i = 0
    for (item in iterator) {
        if (i < count) {
            yield item
        }
        i += 1
    }
}

# Takes elements while a condition is true
# @param Object iterator The iterator
# @param Object callback The condition
# @yield Object The elements
func takeWhile (iterator, callback) {
    stop = false
    for (item in iterator) {
        if (!stop && !typecast (Bool, callback (item))) {
            stop = true
        }
        if (stop) {
            continue
        }
        yield item
    }
}

# Skips the first n elements
# @param Object iterator The iterator
# @param Int The number of elements to skip
# @yield The remaining elements
func skip (iterator, count) {
    i = 0
    for (item in iterator) {
        if (i >= count) {
            yield item
        }
        i += 1
    }
}

# Skips elements while a condition is true
# @param Object iterator The iterator
# @param Object callback The condition
# @yield Object The remaining elements
func skipWhile (iterator, callback) {
    _skip = true
    for (item in iterator) {
        if (_skip && !typecast (Bool, callback (item))) {
            _skip = false
        }
        if (_skip) {
            continue
        }
        yield item
    }
}

# Adds up all items of an iterable
# @param Object iterable The iterable
# @param **Object kwargs Optional arguments
# @optional Object start The result to start with
# @return Object The result
func sum (iterable, **kwargs) {
    # TODO: Use trait Enumerable/Iterable for iterable
    result = 0
    for (key in kwargs) {
        match (key) {
            case "start" => result = kwargs [key]
        }
    }
    for (item in iterable) {
        result += item
    }
    return result
}

func zip (*iterables) {
    result = []
    iteratorCount = len (iterables)
    iterators = []
    iteratorIndices = []
    iteratorCounts = []
    for (iterator in iterables) {
        iterators.append (iterator)
        iteratorIndices.append (0)
        iteratorCounts.append (len (iterator))
    }
    while (true) {
        objs = []
        for (i = 0; i < iteratorCount; i += 1) {
            if (iteratorCounts [i] == iteratorIndices [i]) {
                return result
            }
            objs.append (iterators [i] [iteratorIndices [i]])
            iteratorIndices [i] += 1
        }
        result.append (Tuple (objs))
    }
}

# Reduces an iterable by iterating over it,
# passing, for all items, the result of the previous item and the current item
# to a function, whose result is then returned to the caller.
# @param Object iterable The iterable
# @param Object callback The callback
# @param **Object kwargs Optional arguments
# @optional Object start The result to start with
# @return Object The result of the reduction
func reduce (iterable, callback, **kwargs) {
    # TODO: Use trait Enumerable/Iterable for iterable
    # TODO: Use trait Callable/Invokable for callback
    result = 0
    for (key in kwargs) {
        match (key) {
            case "start" => result = kwargs [key]
        }
    }
    for (item in iterable) {
        result = callback (result, item)
    }
    return result
}

# Iterates through an iterable, passing each to a function.
# If that functions returns true, the item is appended to a list,
# which is then returned to the caller.
# @param Object iterable The iterable
# @param Object callback The callback
# @return List The filtered items
func filter (iterable, callback) {
    # TODO: Use trait Enumerable/Iterable for iterable
    # TODO: Use trait Callable/Invokable for callback
    for (item in iterable) {
        if (callback (item)) {
            yield item
        }
    }
}

# Iterates through an iterable, passing each to a function.
# The return value of each function call is appended to a list,
# which is then returned to the caller.
# @param Object iterable The iterable
# @param Object callback The callback
# @return List The mapped items
func map (iterable, callback) {
    # TODO: Use trait Enumerable/Iterable for iterable
    # TODO: Use trait Callable/Invokable for callback
    for (item in iterable) {
        yield callback (item)
    }
}