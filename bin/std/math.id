# Author: SplittyDev (github.com/splittydev)

use typecast from std.builtin
use ArgumentException, TypeException from std.exceptions

# The Pi constant
PI = 3.14159265358979

# The E constant
E = 2.71828182845905

# The square root of 2
SQRT2 = 1.41421356237309

# Logarithm of e to base 2
LOG2E = 1.44269504088896

# Logarithm of e to base 10
LOG10E = 0.43429448190325

func fibonacci (x, **kwargs) {

    # Make sure that x is of type Int
    typecast (Int, x)

    # Special case: x < 0
    if (x < 0) {
        raise ArgumentException ("x", "Value has to be non-negative")
    }

    # Default algorithm
    method = "fastdoubling"

    # Algorithms
    algorithms = {
        /* Naive algorithm
         * Easy to implement, but extremely slow.
         * Details:
         * F(n + 2) = F(n + 1) + F(n)
         */
        "naive": lambda () {
            a = 0
            b = 1
            for (i = 0; i < x; i += 1) {
                c = a + b
                a = b
                b = c
            }
            return a
        },
        /* Fast matrix algorithm
         * Way faster than the naive algorithm, but has
         * a constant factor slowdown compared to the
         * fast doubling algorithm.
         * Details:
         * [1  1] ^ n   [F(n + 1)  F(n - 0)]
         * [1  0]     = [F(n + 0)  F(n - 1)]
         */
        /* Currently not working
        "fastmatrix": lambda () {
            matrix = [1, 1, 1, 0]
            result = [1, 0, 0, 1]
            while (x != 0) {
                if ((x % 2) == 0) {
                    print ("x mod 2 == 0")
                    print ("Current result: " + repr (result))
                    result = [
                        (result [0] * matrix [0]) +
                        (result [1] * matrix [2]),
                        (result [0] * matrix [1]) +
                        (result [1] * matrix [3]),
                        (result [2] * matrix [0]) +
                        (result [3] * matrix [2]),
                        (result [2] * matrix [1]) +
                        (result [3] * matrix [3])
                    ]
                    print ("Updated result: " + repr (result))
                }
                x /= 2
                matrix = [
                    (matrix [0] * matrix [0]) +
                    (matrix [1] * matrix [2]),
                    (matrix [0] * matrix [1]) +
                    (matrix [1] * matrix [3]),
                    (matrix [2] * matrix [0]) +
                    (matrix [3] * matrix [2]),
                    (matrix [2] * matrix [1]) +
                    (matrix [3] * matrix [3])
                ]
                print ("New matrix: " + repr (matrix))
            }
            print ("Result matrix: " + repr (result))
            return result [1]
        }, */
        /* Extremely fast doubling algorithm
         * This one is even faster than the matrix algorithm.
         * Details:
         * F(2n + 0) = F(n + 0) * (2 * F(n + 1) - F(n))
         * F(2n + 1) = F(n + 1) ^  2 + F(n + 0) ^ 2
         */
        "fastdoubling": lambda () {
            a = 0
            b = 1
            for (i = 31; i >= 0; i -= 1) {
                d = a * (b * 2 - a)
                e = a * a + b * b
                a = d
                b = e
                if (((x >> i) & 1) != 0) {
                    c = a + b
                    a = b
                    b = c
                }
            }
            return a
        }
    }

    # Handle optional arguments
    for (key in kwargs) {
        current = kwargs [key]
        match (key) {
            case "method"  { 
                typecast (Str, current)
                if (current == "default") {
                    current = method
                }
                if (!algorithms.contains (current)) {
                    raise ArgumentException ("method", "Algorithm '{0}' not found".format (current))
                }
                method = current
            }
        }
    }

    # Compute the fibonacci series
    return algorithms [method] ()
}

func factorial (x, **kwargs) {

    # Make sure that x is of type Int
    typecast (Int, x)

    # Default algorithm
    method = "naive"

    # Special case: x == 0
    if (x == 0) {
        return 1
    }

    # Special case: x < 3
    if (x < 3) {
        return x
    }

    # Algorithms
    algorithms = {
        /* The naive algorithm.
         * Easy to implement and accurate, but slow.
         */
        "naive": lambda () {
            # Naive algorithm
            sum = 1
            for (i = 1; i <= x; i += 1) {
                sum *= i
            }
            return sum
        },
        /* Stirling's approximation
         * Very fast but also very inaccurate.
         */
        "stirling": lambda () {
            # Added one to the result to simulate ceiling behavior
            return 1 + Int (pow (E, -x) * Float (pow (x, x)) * Float (sqrt (PI * Float ((2 * x)))))
        },
    }

    # Handle optional arguments
    for (key in kwargs) {
        current = kwargs [key]
        match (key) {
            case "method"  { 
                typecast (Str, current)
                if (current == "default") {
                    current = method
                }
                if (!algorithms.contains (current)) {
                    raise ArgumentException ("method", "Algorithm '{0}' not found".format (current))
                }
                method = current
            }
        }
    }

    # Compute the factorial
    return algorithms [method] ()
}

func exp (x, **kwargs) {

    # Make sure that x is a Float
    if (x is Int) {
        x = Float (x)
    }
    typecast (Float, x)

    # Work with positive values
    sign = false
    if (x < 0.0) {
        sign = true
        x = abs (x)
    }

    # Special case: x ~> 702
    # 702.2884533631839199...
    if (x > 702.2884533631839) {
        raise ArgumentException ("x", "Value too big; Result would exceed the bounds of Float")
    }

    # Default algorithm
    method = "default"

    # Algorithms
    algorithms = {
        "default": lambda () {
            eps = 0.0000000000000000001
            elem = 1.0
            sum = 0.0
            i = 1.0
            do {
                sum += elem
                elem *= x / i
                i += 1.0
            } while (elem >= eps)
            return sum
        },
        "pade": lambda () => 1.0 + x * (6.0 + x) / (6.0 - 2.0 * x),
    }

    # Handle optional arguments
    for (key in kwargs) {
        current = kwargs [key]
        match (key) {
            case "method"  { 
                typecast (Str, current)
                if (current == "default") {
                    current = method
                }
                if (!algorithms.contains (current)) {
                    raise ArgumentException ("method", "Algorithm '{0}' not found".format (current))
                }
                method = current
            }
        }
    }

    # Compute the exponential
    sum = algorithms [method] ()
    if (sign) {
        return 1.0 / sum
    }
    return sum
}

func log2 (v) {
    b = [0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000]
    S = [1, 2, 4, 8, 16]
    r = 0
    for (i = 4; i >= 0; i -= 1) {
        if (v & b [i]) {
            v >>= S [i]
            r |= S [i]
        }
    }
    return r
}

func pow (base, exp, **kwargs) {

    # Make sure that exp is of type Int
    typecast (Int, exp)

    # Make sure that base is either of type Int or Float
    if (base isnot Int && base isnot Float) {
        raise TypeException ("base", "Int|Float")
    }

    # Special case: exp == 0
    if (exp == 0) {
        return 1
    }

    # Special case: exp == 2
    if (exp == 2) {
        return base * base
    }

    # Work with positive exponent
    # if, and only if, base is of type Int
    sign = false
    if (base is Int && exp < 0) {
        sign = true
        exp = abs (exp)
    }

    # Verify that the exponent fits into an unsigned byte
    if (exp > 255) {
        raise ArgumentException ("exp", "Exponent exceeds the allowed 8-bit bounds")
    }

    # Default algorithm
    method = "fastpow"

    # Use floatpow algorithm if base is of type Float
    if (base is Float) {
        method = "floatpow"
    }

    # Use fast shift algorithm if base equals 2
    else if (base == 2) {
        method = "shiftpow"
    }

    # Algorithms
    algorithms = {
        "intpow": lambda () {
            typecast (Int, base)
            result = 1
            while (exp > 0) {
                if ((exp & 1) == 1) {
                    result *= base
                }
                exp >>= 1
                base *= base
            }
            return result
        },
        "altpow": lambda () {
            typecast (Int, base)
            tmp = pow (base, exp / 2)
            if (exp % 2 == 0) {
                return tmp * tmp
            }
            return base * tmp * tmp
        },
        "floatpow": lambda () {
            tmp = Float (pow (base, exp / 2))
            if (exp % 2 == 0) {
                return tmp * tmp
            }
            if (exp < 0) {
                return (tmp * tmp) / base
            }
            return base * tmp * tmp
        },
        "shiftpow": lambda () {
            typecast (Int, base)
            if (base != 2) {
                raise Exception ("The 'shiftpow' algorithm only works when 'base' equals 2")
            }
            return 1 << exp
        },
        "fastpow": lambda () {
            typecast (Int, base)
            lut = [
                0, 1, 2, 2, 3, 3, 3, 3,
                4, 4, 4, 4, 4, 4, 4, 4,
                5, 5, 5, 5, 5, 5, 5, 5,
                5, 5, 5, 5, 5, 5, 5, 5,
                6, 6, 6, 6, 6, 6, 6, 6,
                6, 6, 6, 6, 6, 6, 6, 6,
                6, 6, 6, 6, 6, 6, 6, 6,
                6, 6, 6, 6, 6, 6, 6, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255,
            ]
            result = 1
            current = 0
            while (true) {
                endloop = false
                match (lut [exp]) {
                    case 255 {
                        endloop = true
                        if (base == 1) {
                            result = 1
                        } else if (base == -1) {
                            result = 1 - 2 * (exp & 1)
                        }
                        result = 0
                    }
                    case 6 {
                        if (exp & 1) {
                            result *= base
                        }
                        exp >>= 1
                        base *= base
                    }
                    case 5 {
                        if (exp & 1) {
                            result *= base
                        }
                        exp >>= 1
                        base *= base
                    }
                    case 4 {
                        if (exp & 1) {
                            result *= base
                        }
                        exp >>= 1
                        base *= base
                    }
                    case 3 {
                        if (exp & 1) {
                            result *= base
                        }
                        exp >>= 1
                        base *= base
                    }
                    case 2 {
                        if (exp & 1) {
                            result *= base
                        }
                        exp >>= 1
                        base *= base
                    }
                    case 1 {
                        if (exp & 1) {
                            result *= base
                        }
                        endloop = true
                    }
                    case _ {
                        endloop = true
                    }
                }
                if (endloop) {
                    break
                }
            }
            return result
        },
    }

    # Handle optional arguments
    for (key in kwargs) {
        current = kwargs [key]
        match (key) {
            case "method"  { 
                typecast (Str, current)
                if (current == "default") {
                    current = method
                }
                if (!algorithms.contains (current)) {
                    raise ArgumentException ("method", "Algorithm '{0}' not found".format (current))
                }
                method = current
            }
        }
    }

    # Compute the integer power
    result = algorithms [method] ()
    if (sign) {
        return 1.0 / Float (result)
    }
    return result
}

func sqrt (x, **kwargs) {

    # Make sure that x is a Float
    if (x is Int) {
        x = Float (x)
    }
    typecast (Float, x)

    # Default algorithm
    method = "babylonian"

    # Default precision
    precision = pow (10, -7) # 1e^-7

    # Algorithms
    algorithms = {
        "babylonian": lambda () {
            n = x / 2.0
            last = 0.0
            while (n != last) {
                last = n
                n = (n + (x / n)) / 2.0
            }
            return n
        },
        "babylonian2": lambda () {
            i = 0.0
            while ((i * i) < x) {
                i += 0.1
            }
            x1 = i
            x2 = 0.0
            for (j = 0; j < 10; j += 1) {
                x2 = x
                x2 /= x1
                x2 += x1
                x2 /= 2.0
                x1 = x2
            }
            return x2
        },
        "bakhsali": lambda () {
            i = 0.0
            while ((i * i) <= x) {
                i += 1.0
            }
            i -= 1.0
            d = x - (i * i)
            p = d / (2.0 * i)
            a = i + p
            return a - (p * p) / (2.0 * a)
        },
        "newtons": lambda () {
            lower = 0.0
            upper = 0.0
            guess = 0.0
            if (x < 1.0) {
                lower = x
                upper = 1.0
            } else {
                lower = 1.0
                upper = x
            }
            while ((upper - lower) > precision) {
                guess = (lower + upper) / 2.0
                if ((guess * guess) > x) {
                    upper = guess
                } else {
                    lower = guess
                }
            }
            return (lower + upper) / 2.0
        },
        "newtons2": lambda () {
            if (2.0 > x) {
                return x
            }
            n = 0.0
            p = 0.0
            low = 0.0
            high = x
            while (high > low + precision) {
                n = (high + low) / 2.0
                p = n * n
                if (x < p) {
                    high = n
                } else if (x > p) {
                    low = n
                } else {
                    break
                }
            }
            if (x == p) {
                return n
            }
            return low
        }
    }

    # Handle optional arguments
    for (key in kwargs) {
        current = kwargs [key]
        match (key) {
            case "method"  { 
                typecast (Str, current)
                if (current == "default") {
                    current = method
                }
                if (!algorithms.contains (current)) {
                    raise ArgumentException ("method", "Algorithm '{0}' not found".format (current))
                }
                method = current
            }
            case "precision" {
                typecast (Int, current)
                precision = max (pow (10, -current), pow (10, -15)) # 1e^-current
            }
        }
    }

    # Compute the square root
    return algorithms [method] ()
}

func sin (x, **kwargs) {

    # Make sure that x is a Float
    if (x is Int) {
        x = Float (x)
    }
    typecast (Float, x)

    # Special case: x = 0
    if (x == 0.0) {
        return x
    }

    # Default precision
    precision = 20.0

    # Handle optional arguments
    for (key in kwargs) {
        current = kwargs [key]
        match (key) {
            case "precision" {
                if (current is Int) {
                    current = Float (current)
                }
                typecast (Float, current)
                precision = current
            }
        }
    }

    # Reduce x to range [-2Pi, 2Pi]
    x = x - Float (Int (x * (1.0 / (2.0 * PI)))) * 2.0 * PI

    # Reduce x to range [-Pi/2, Pi/2]
    x = min (x, PI - x)
    x = max (x, -PI - x)
    x = min (x, PI - x)

    # Taylor series approximation
    sum = 1.0
    x2 = x * x
    for (n = precision - 1.0; n >= 0.0; n -= 1.0) {
        n2 = 2.0 * n
        sum = 1.0 - x2 / (n2 + 2.0) / (n2 + 3.0) * sum
    }
    return x * sum
}

func cos (x, **kwargs) {

    # Make sure that x is a Float
    if (x is Int) {
        x = Float (x)
    }
    typecast (Float, x)

    # Special case: x = 0
    if (x == 0.0) {
        return 1.0
    }

    # Default precision
    precision = 20.0

    # Handle optional arguments
    for (key in kwargs) {
        current = kwargs [key]
        match (key) {
            case "precision" {
                if (current is Int) {
                    current = Float (current)
                }
                typecast (Float, current)
                precision = current
            }
        }
    }

    # Reduce x to range [-2Pi, 2Pi]
    x = x - Float (Int (x * (1.0 / (2.0 * PI)))) * 2.0 * PI

    # Reduce x to range [-Pi/2, Pi/2]
    x = min (x, PI - x)
    x = max (x, -PI - x)
    x = min (x, PI - x)
    
    # McLaurin series approximation
    sum = 1.0
    x2 = x * x
    for (n = precision - 1.0; n >= 0; n -= 1.0) {
        n2 = 2.0 * n
        sum = 1.0 - x2 / (n2 + 2.0) / (n2 + 1.0) * sum
    }
    return sum
}

func zs_sin (x) {
    t0 = lambda (x) => 1.0
    t1 = lambda (x) => x
    t2 = lambda (x) => 2.0 * x * x - 1.0
    t3 = lambda (x) => 4.0 * x * x * x - 3.0 * x
    t4 = lambda (x) => 8.0 * x * x * x * x - 8.0 * x * x + 1.0
    t5 = lambda (x) => 16.0 * x * x * x * x * x - 20.0 * x * x * x + 5.0 * x
    c0 =  1.276278962
    c1 = -0.285261569
    c2 =  0.009118016
    c3 = -0.000136587
    c4 =  0.000001185
    c5 = -0.000000007
    p = lambda (z) =>
          c0 * t0 (z)
        + c1 * t1 (z)
        + c2 * t2 (z)
        + c3 * t3 (z)
        + c4 * t4 (z)
        + c5 * t5 (z)
    w = 4.0 * x
    z = 2.0 * w * w - 1.0
    return p (z) * w
}

func min (x, y) {
    if (x isnot Int && x isnot Float) {
        raise TypeException ("x", "Int|Float")
    } else if (y isnot Int && y isnot Float) {
        raise TypeException ("y", "Int|Float")
    }
    if (x is Float && y isnot Float) {
        y = Float (y)
    } else if (y is Float && x isnot Float) {
        x = Float (x)
    }
    if (x < y) {
        return x
    }
    return y
}

func max (x, y) {
    if (x isnot Int && x isnot Float) {
        raise TypeException ("x", "Int|Float")
    } else if (y isnot Int && y isnot Float) {
        raise TypeException ("y", "Int|Float")
    }
    if (x is Float && y isnot Float) {
        y = Float (y)
    } else if (y is Float && x isnot Float) {
        x = Float (x)
    }
    if (x > y) {
        return x
    }
    return y
}

func floor (x) {
    if (x is Int) {
        return x
    }
    typecast (Float, x)
    return Int (x)
}

func abs (x) {
    if (x isnot Int && x isnot Float) {
        raise TypeException ("x", "Int|Float")
    }
    if (x < 0) {
        return -x
    }
    return x
}