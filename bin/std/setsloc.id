class Set {
    func Set (self, **kwargs) {
        self.list = []
        self.cardinality = 0
        self.capacity = -1
        foreach (key in kwargs) {
            match (key) {
                case "capacity" => self.capacity = typecast (Int, kwargs [key])
                case "items" => (lambda () {
                    foreach (i in typecast (List, kwargs [key]))
                        self.add (i)
                }) ()
            }
        }
    }
    func add (self, item) {
        if (self.cardinality == self.capacity)
            raise Exception ("Maximum capacity reached.")
        if (self.contains (item))
            raise Exception ("The item is already an element of the set.")
        self.list.add (item)
        self.cardinality += 1
    }
    func remove (self, item) {
        if (!self.contains (item))
            raise Exception ("The item is not an element of the set.")
        i = 0
        foreach (x in self.list) {
            if (x == item) {
                self.list.removeAt (i)
                break
            }
            i += 1
        }
        self.cardinality -= 1
    }
    func empty (self) {
        return self.cardinality == 0
    }
    func union (self, other) {
            typecast (Set, other)
            set = Set (items: other.list)
            foreach (item in self.list) {
                if (!other.contains (item))
                    set.add (item)
            }
            return set
    }
    func intersection (self, other) {
        typecast (Set, other)
        set = Set ()
        foreach (item in self.list) {
            if (other.contains (item))
                set.add (item)
        }
        return set
    }
    func difference (self, other) {
        typecast (Set, other)
        set = Set ()
        foreach (item in self.list) {
            if (!other.contains (item))
                set.add (item)
        }
        return set
    }
    func superset (self, other) {
        typecast (Set, other)
        i = 0
        foreach (item in self.list)
            if (other.contains (item))
                i += 1
        return other.cardinality == i
    }
    func subset (self, other) {
        typecast (Set, other)
        i = 0
        foreach (item in other.list)
            if (self.contains (item))
                i += 1
        return self.cardinality == i
    }
    func contains (self, item) {
        return (self.list).contains (item)
    }
    func __len__ (self) {
        return self.cardinality
    }
    func __str__ (self) {
        return self.__repr__ ()
    }
    func __repr__ (self) {
        return repr (self.list)
    }
    func __getIndex__ (self, i) {
        return self.list [i]
    }
    func __iter__ (self) {
        for (i = 0; i < self.cardinality; i += 1) {
            yield self [i]
        }
    }
    func create (lst) {
        return Set (items: typecast (List, lst))
    }
    func unionOf (a, b) {
        return typecast (Set, a).union (b)
    }
    func intersectionOf (a, b) {
        return typecast (Set, a).intersection (b)
    }
    func differenceOf (a, b) {
        return typecast (Set, a).difference (b)
    }
    func supersetOf (a, b) {
        return typecast (Set, a).superset (b)
    }
    func subsetOf (a, b) {
        return typecast (Set, a).subset (b)
    }
}