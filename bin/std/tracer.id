/**
 * Provides function decorators for
 * tracing and debugging function calls
 * @module std/tracer
 * @author SplittyDev
 */

global __STDLIB = true
global __STDLIB_TRACER = true
use nameof from std.reflection

/**
 * This class is meant to be used internally.
 */
class TraceNode {
    func TraceNode (self, f) {
        self.f = f
        self.fname = nameof (f)
        self.fsig = null
        self.fresult = null
        self.fchilds = List ()
    }

    func addchild (self, f) {
        node = TraceNode (f)
        self.fchilds.append (node)
        trace.parent = node
    }

    func __invoke__ (self, *args) {
        self.fsig = "#{self.fname} #{repr (args)}"
        self.fresult = self.f (*args)
        return self.fresult
    }
}

/**
 * Starts the tracer.
 * All calls to functions decorated with @trace
 * will be recorded and a rich overview can be
 * generated by calling tracer_report.
 */
func tracer_start () {
    trace.items = List ()
}

trace.parent = null
trace.items = null

/**
 * Records function calls if tracer_start was called.
 */
func trace (f) {
    func wrapper (*args) {
        if (trace.items is Null) {
            return f (*args)
        }
        if (trace.parent isnot Null && trace.parent.f != f) {
            trace.items [trace.items.index (trace.parent)].addchild (f)
        } else {
            trace.parent = TraceNode (f)
            trace.items.append (trace.parent)
        }
        return trace.parent (*args)
    }
    return wrapper
}

/**
 * Generates a rich overview of function calls recorded
 * by the tracer, including the function's name, the supplied
 * parameters, the returned object and calls, made by that function
 * (but only if the called function is also decorated with @trace).
 */
func tracer_report () {
    tracer_report.index = 0
    if (trace.items is Null || len (trace.items) == 0)
        return null
    print ("[Trace]")
    tracer = trace.items
    func trace_end_rec (tracer, depth, parent) {
        for (j = 0; j < len (parent.fchilds); j += 1) {
            node = parent.fchilds [j]
            just = "".ljust (depth * 2)
            print ("#{just}- [#{tracer_report.index}] #{node.fsig} => #{repr (node.fresult)}")
            tracer_report.index += 1
            if (len (node.fchilds) > 0) {
                trace_end_rec (tracer, depth + 1, node)
            }
        }
    }
    for (i = 0; i < len (tracer); i += 1) {
        node = tracer [i]
        print ("- [#{tracer_report.index}] #{node.fsig} => #{repr (node.fresult)}")
        tracer_report.index += 1
        if (len (node.fchilds) > 0) {
            trace_end_rec (tracer, 1, node)
        }
    }
}