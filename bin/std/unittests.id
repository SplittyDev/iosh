use AssertionException, describe, expect from testing

# IodineClosure generators are broken
func generatorTest () {
    yield 1;
    yield 2;
    yield 3;
}

func fail (*args) {
    if (len (args) == 1) {
        raise AssertionException (typecast (Str, args [0]))
    } else {
        raise AssertionException ("Test terminated by user")
    }
}

describe ('stdlib', lambda (test) {

    # builtin.id
    test.describe ('builtin', lambda (test) {

        # builtin.id repr
        test.describe ('repr', lambda (test) {
            test.it ('should work with strings', lambda () {
                expect (repr ('hello')).to.equal ('"hello"')
            })
            test.it ('should work with integers', lambda () {
                expect (repr (1234)).to.equal ('1234')
                expect (repr (0xFFFFFFFFFFFFFFFFL)).to.equal ('18446744073709551615')
            })
            test.it ('should work with tuples', lambda () {
                expect (repr ((1, 2, 3, 4))).to.equal ('(1, 2, 3, 4)')
                expect (repr (("a", "b", "c"))).to.equal ('("a", "b", "c")')
            })
            test.it ('should work with dictionaries', lambda () {
                expect (repr ({ "a": 1, "b": 2 })).to.equal ('{"b" = 2, "a" = 1}');
            })
            test.it ('should work with lists', lambda () {
                expect (repr ([1, 2, 3, 4])).to.equal ('[1, 2, 3, 4]')
                expect (repr ([null, null, null])).to.equal ('[null, null, null]')
            })
            test.it ('should work with collections', lambda () {
                expect (repr (Array (items: [1, 2, 3, 4]))).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should work with null', lambda () {
                expect (repr (null)).to.equal ('null')
            })
        })

        # builtin.id type
        test.describe ('type', lambda (test) {
            test.it ('should return the correct type', lambda () {
                expect (type (Str)).to.equal (Str.__type__)
                expect (type (type)).to.equal (type.__type__)
                expect (type (null)).to.equal (null.__type__)
                expect (type ('test')).to.equal ('test'.__type__)
            })
        })

        # builtin.id range
        test.describe ('range', lambda (test) {
            test.it ('should work with one argument', lambda () {
                expect (List (range (1))).to.equal ([0])
                expect (List (range (2))).to.equal ([0, 1])
            })
            test.it ('should work with two arguments', lambda () {
                expect (List (range (0, 5))).to.equal ([0, 1, 2, 3, 4])
                expect (List (range (1, 6))).to.equal ([1, 2, 3, 4, 5])
            })
            test.it ('should work with three arguments', lambda () {
                expect (List (range (0, 10, 2))).to.equal ([0, 2, 4, 6, 8])
                expect (List (range (1, 10, 2))).to.equal ([1, 3, 5, 7, 9])
            })
            test.it ('should yield the same values as the range operator', lambda () {
                expect (List (range (10))).to.equal (List (0 .. 10))
                expect (List (range (0, 10))).to.equal (List (0 .. 10))
                expect (List (range (0, 11))).to.equal (List (0 ... 10))
                expect (List (range (-10, 11))).to.equal (List (-10 ... 10))
            })
        })

        # builtin.id len
        test.describe ('len', lambda (test) {
            test.it ('should work with collections', lambda () {
                expect (len (Set  ())).to.equal (0)
                expect (len (Array (items: [1, 2, 3, 4]))).to.equal (4)
                expect (len (Stack (items: [1, 2, 3, 4]))).to.equal (4)
            })
            test.it ('should work with iterables', lambda () {
                expect (len (List ())).to.equal (0)
                expect (len ([1, 2, 3, 4])).to.equal (4)
            })
            test.it ('should work with generators', lambda () {
                expect (len (generatorTest ())).to.equal (3)
            })
        })

        # builtin.id typecast
        test.describe ('typecast', lambda (test) {
            test.it ('should work with all types', lambda () {
                arr = Array ()
                expect (typecast (Int, 1234)).to.equal (1234)
                expect (typecast (Str, "hello")).to.equal ("hello")
                expect (typecast (Null, null)).to.equal (null)
                expect (typecast (Array, arr)).to.equal (arr)
            })
        })

        # builtin.id intcast
        test.describe ('intcast', lambda (test) {
            test.it ('should work with Int literals', lambda () {
                expect (intcast (0)).to.equal (0)
                expect (intcast (1337)).to.equal (1337)
            })
            test.it ('should work with BigInt literals', lambda () {
                # Compiler bug: expect (intcast (0L)).to.equal (0L)
                expect (intcast (0xFFFFFFFFFFFFFFFFL)).to.equal (0xFFFFFFFFFFFFFFFFL)
            })
        })

        # builtin.id hex
        test.describe ('hex', lambda (test) {
            test.it ('should produce the correct hex string', lambda () {
                expect (hex ([255], prefix: true)).to.equal ("0xff")
                expect (hex ([170, 187, 204, 221, 238, 255])).to.equal ("aabbccddeeff")
            })
        })
    })
    
    # collections.id
    test.describe ('collections', lambda (test) {

        # collections.id Array
        test.describe ('Array', lambda (test) {
            test.it ('should correctly preallocate space', lambda () {
                expect (len (Array (capacity: 0))).to.equal (0)
                expect (len (Array (capacity: 100))).to.equal (100)
            })
            test.it ('should correctly prefill itself', lambda () {
                expect (List (Array (items: [1, 2, 3, 4]))).to.equal ([1, 2, 3, 4])
            })
            test.it ('should correctly count its items', lambda () {
                expect (Array (items: [1, 2, 3, 4]).count ()).to.equal (4)
            })
            test.it ('should correctly clear its items', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                arr.clear ()
                expect (len (arr)).to.equal (0)
            })
            test.it ('should correctly report whether it is empty', lambda () {
                expect (Array ().empty ()).to.be._true ()
                expect (Array (items: [1, 2, 3, 4]).empty ()).to.be._false ()
            })
            test.it ('should correctly add items to itself', lambda () {
                arr = Array ()
                arr.add (1)
                arr.add (2)
                expect (List (arr)).to.equal ([1, 2])
            })
            test.it ('should correctly remove items from itself', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                arr.remove (1)
                arr.remove (3)
                expect (List (arr)).to.equal ([2, 4])
                arr = Array (items: [1, 2, 3, 4])
                arr.removeat (1)
                arr.removeat (2)
                expect (List (arr)).to.equal ([1, 3])
            })
            test.it ('should correctly report whether it contains an item', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr.contains (2)).to.be._true ()
                expect (arr.contains (5)).to.be._false ()
            })
            test.it ('should correctly fill itself with items', lambda () {
                arr = Array (capacity: 5)
                expect (List (arr.fill (0))).to.equal ([0, 0, 0, 0, 0])
                expect (List (arr.fill ('a'))).to.equal (['a', 'a', 'a', 'a', 'a'])
            })
            test.it ('should correctly fill part of itself with items', lambda () {
                arr = Array (items: ['a', 'b', 'b'])
                expect (List (arr.fillrange (2, 1, 'c'))).to.equal (['a', 'b', 'c'])
                arr = Array (items: ['0', '1', '1', '0'])
                expect (List (arr.fillrange (1, 2, '0'))).to.equal (['0', '0', '0', '0'])
            })
            test.it ('should correctly report its length', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr.__len__ ()).to.equal (4)
            })
            test.it ('should correctly override its string representation', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr.__str__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly report its string representation', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr.__repr__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly return items by index', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr [0]).to.equal (1)
                expect (arr [3]).to.equal (4)
            })
            test.it ('should correctly set items by index', lambda () {
                arr = Array (items: [1, 0, 0, 4])
                arr [1] = 2
                arr [2] = 3
                expect (List (arr)).to.equal ([1, 2, 3, 4])
            })
            test.it ('should be iterable', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr is Iterable).to.be._true ()
                lst = [1, 2, 3, 4]
                i = 0
                for (item in arr) {
                    expect (item).to.equal (lst [i])
                    i += 1
                }
            })
        })
        
        # collections.id Set
        test.describe ('Set', lambda (test) {
            test.it ('should correctly prefill itself', lambda () {
                expect (List (Set (items: [1, 2, 3, 4]))).to.equal ([1, 2, 3, 4])
            })
            test.it ('should correctly clear its items', lambda () {
                set = Set (items: [1, 2, 3, 4])
                set.clear ()
                expect (len (set)).to.equal (0)
            })
            test.it ('should correctly count its items', lambda () {
                expect (Set (items: [1, 2, 3, 4]).count ()).to.equal (4)
            })
            test.it ('should correctly report whether it is empty', lambda () {
                expect (Set ().empty ()).to.be._true ()
                expect (Set (items: [1, 2, 3, 4]).empty ()).to.be._false ()
            })
            test.it ('should correctly add items to itself', lambda () {
                set = Set ()
                set.add (1)
                set.add (2)
                expect (List (set)).to.equal ([1, 2])
            })
            test.it ('should correctly remove items from itself', lambda () {
                set = Set (items: [1, 2, 3, 4])
                set.remove (1)
                set.remove (3)
                expect (List (set)).to.equal ([2, 4])
            })
            test.it ('should correctly calculate the union', lambda () {
                set1 = Set (items: [1, 2])
                set2 = Set (items: [3, 4])
                expect (List (set1.union (set2))).to.equal ([3, 4, 1, 2])
            })
            test.it ('should correctly calculate the intersection', lambda () {
                set1 = Set (items: [1, 2, 3, 4])
                set2 = Set (items: [3, 4, 5, 6])
                expect (List (set1.intersection (set2))).to.equal ([3, 4])
            })
            test.it ('should correctly calculate the difference', lambda () {
                set1 = Set (items: [2, 4, 6, 8])
                set2 = Set (items: [1, 4, 5, 8])
                expect (List (set1.difference (set2))).to.equal ([2, 6])
                expect (List (set2.difference (set1))).to.equal ([1, 5])
            })
            test.it ('should correctly determine whether it is a superset', lambda () {
                set1 = Set (items: [1, 2, 3, 4, 5, 6, 7, 8, 9])
                set2 = Set (items: [   2,    4,    6,    8   ])
                expect (set1.superset (set2)).to.be._true ()
                expect (set2.superset (set1)).to.be._false ()
            })
            test.it ('should correctly determine whether it is a subset', lambda () {
                set1 = Set (items: [   2,    4,    6,    8   ])
                set2 = Set (items: [1, 2, 3, 4, 5, 6, 7, 8, 9])
                expect (set1.subset (set2)).to.be._true ()
                expect (set2.subset (set1)).to.be._false ()
            })
            test.it ('should correctly report whether it contains an item', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set.contains (2)).to.be._true ()
                expect (set.contains (5)).to.be._false ()
            })
            test.it ('should correctly report its length', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set.__len__ ()).to.equal (4)
            })
            test.it ('should correctly override its string representation', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set.__str__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly report its string representation', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set.__repr__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly return items by index', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set [0]).to.equal (1)
                expect (set [3]).to.equal (4)
            })
            test.it ('should be iterable', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set is Iterable).to.be._true ()
                lst = [1, 2, 3, 4]
                i = 0
                for (item in set) {
                    expect (item).to.equal (lst [i])
                    i += 1
                }
            })
        })
        
        # collections.id GenericSet
        test.describe ('GenericSet', lambda (test) {
            test.it ('should correctly infer the type', lambda () {
                set = GenericSet ()
                set.add (1)
                set.add (2)
                expect (set.type).to.equal (Int)
            })
            test.it ('should not accept other types', lambda () {
                set = GenericSet ()
                set.add (0)
                raised = false
                try {
                    set.add ('a')
                } except {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should accept its type as keyword argument', lambda () {
                # Compiler bug: super (kwargs) consumes the **kwargs
                #set = GenericSet (T: Str)
                #set.add ('a')
                #set.add ('b')
                #set.add ('c')
            })
        })

        # collections.id Stack
        test.describe ('Stack', lambda (test) {
            test.it ('should correctly prefill itself', lambda () {
                expect (List (Stack (items: [1, 2, 3, 4]))).to.equal ([4, 3, 2, 1])
            })
            test.it ('should correctly clear its items', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                stack.clear ()
                expect (len (stack)).to.equal (0)
            })
            test.it ('should correctly count its items', lambda () {
                expect (Stack (items: [1, 2, 3, 4]).count ()).to.equal (4)
            })
            test.it ('should correctly report whether it is empty', lambda () {
                expect (Stack ().empty ()).to.be._true ()
                expect (Stack (items: [1, 2, 3, 4]).empty ()).to.be._false ()
            })
            test.it ('should raise if items are added using Stack.add', lambda () {
                stack = Stack ()
                raised = false
                try {
                    stack.add (1)
                    stack.add (2)
                } except {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should correctly push items onto itself', lambda () {
                stack = Stack ()
                stack.push (1)
                stack.push (2)
                expect (List (stack)).to.equal ([2, 1])
            })
            test.it ('should correctly pop items from itself', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                stack.pop ()
                stack.pop ()
                expect (List (stack)).to.equal ([2, 1])
            })
            test.it ('should correctly remove items from itself', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                stack.remove (1)
                stack.remove (3)
                expect (List (stack)).to.equal ([4, 2])
                stack = Stack (items: [1, 2, 3, 4])
                stack.removeat (0)
                stack.removeat (0)
                expect(List (stack)).to.equal ([2, 1])
            })
            test.it ('should correctly report whether it contains an item', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack.contains (2)).to.be._true ()
                expect (stack.contains (5)).to.be._false ()
            })
            test.it ('should correctly report its length', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack.__len__ ()).to.equal (4)
            })
            test.it ('should correctly override its string representation', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack.__str__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly report its string representation', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack.__repr__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly return items by index', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack [0]).to.equal (4)
                expect (stack [3]).to.equal (1)
            })
            test.it ('should correctly set items by index', lambda () {
                stack = Stack (items: [1, 0, 0, 4])
                stack [1] = 3
                stack [2] = 2
                expect (List (stack)).to.equal ([4, 3, 2, 1])
            })
            test.it ('should be iterable', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack is Iterable).to.be._true ()
                lst = [4, 3, 2, 1]
                i = 0
                for (item in stack) {
                    expect (item).to.equal (lst [i])
                    i += 1
                }
            })
        })

        # collections.id GenericStack
        test.describe ('GenericStack', lambda (test) {
            test.it ('should correctly infer the type', lambda () {
                stack = GenericStack ()
                stack.push (1)
                stack.push (2)
                expect (stack.type).to.equal (Int)
            })
            test.it ('should not accept other types', lambda () {
                stack = GenericStack ()
                stack.push (0)
                raised = false
                try {
                    stack.push ('a')
                } except {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should accept its type as keyword argument', lambda () {
                # Compiler bug: super (kwargs) consumes the **kwargs
                #stack = GenericStack (T: Str)
                #stack.add ('a')
                #stack.add ('b')
                #stack.add ('c')
            })
        })
    })
    
    # exceptions.id
    test.describe ('exceptions', lambda (test) {

        # exceptions.id ArgumentException
        test.describe ('ArgumentException', lambda (test) {
            test.it ('should raise', lambda () {
                raised = false
                try {
                    raise ArgumentException ('x', 'test')
                } except (e as ArgumentException) {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should have the right message', lambda () {
                try {
                    raise ArgumentException ('x', 'test')
                } except (e as ArgumentException) {
                    expect (e.message).to.equal ("Argument 'x': test")
                    return;
                }
                fail ('should have raised')
            })
        })

        # exceptions.id TypeException
        test.describe ('TypeException', lambda (test) {
            test.it ('should raise', lambda () {
                raised = false
                try {
                    raise TypeException ('x', 'Str|Int')
                } except (e as TypeException) {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should have the right message', lambda () {
                try {
                    raise TypeException ('x', 'Str|Int')
                } except (e as TypeException) {
                    expect (e.message).to.equal ("Expected 'x' to be of type Str or Int")
                    return;
                }
                fail ('should have raised')
            })
        })
    })

    # functools.id
    test.describe ('functools', lambda (test) {

        # functools.id memoize
        test.describe ('memoize', lambda (test) {
            test.it ('should correctly cache values', lambda () {
                @memoize
                func fib (n) {
                    if (n < 2) {
                        return n
                    }
                    return fib (n - 2) + fib (n - 1)
                }
                fib (31)
                ckeys = [1, 0]
                ckeys.appendrange (List (2 .. 32))
                cvals = [
                    0000001, 0000000, 0000001, 0000002,
                    0000003, 0000005, 0000008, 0000013,
                    0000021, 0000034, 0000055, 0000089,
                    0000144, 0000233, 0000377, 0000610,
                    0000987, 0001597, 0002584, 0004181,
                    0006765, 0010946, 0017711, 0028657,
                    0046368, 0075025, 0121393, 0196418,
                    0317811, 0514229, 0832040, 1346269
                ]
                i = 0
                for (key, value in fib.cache) {
                    expect (key [0]).to.equal (ckeys [i])
                    expect (value).to.equal (cvals [i])
                    i += 1
                }
            })
        })
    })
})