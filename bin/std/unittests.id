/**
 * Provides unit tests for the stdlib
 * @module std/unittests
 * @author SplittyDev
 */

global __STDLIB = true
global __STDLIB_UNITTESTS = true
use * from std.tracer
use stdlib_isdefined from std.info
use AssertionException, describe, expect from testing

func fail (*args) {
    if (len (args) == 1) {
        raise AssertionException (typecast (Str, args [0]))
    } else {
        raise AssertionException ("Test terminated by user")
    }
}

tracer_start ()
describe ('stdlib', lambda (test) {

    # builtin.id
    test.describe ('builtin', lambda (test) {
        if (!stdlib_isdefined ('builtin')) {
            use * from std.builtin
        }

        # builtin.id sort
        test.describe ('sort', lambda (test) {
            test.it ('should correctly sort a List of Int', lambda () {
                lsta = [2, 4, 1, 3]
                lstb = [1, 2, 3, 4]
                expect (sort (lsta)).to.equal (lstb)
            })
            test.it ('should correctly sort a List of Str', lambda () {
                lsta = ['b', 'd', 'a', 'c']
                lstb = ['a', 'b', 'c', 'd']
                expect (sort (lsta)).to.equal (lstb)
            })
            test.it ('should correctly sort a Str', lambda () {
                lsta = 'bdac'
                lstb = ['a', 'b', 'c', 'd']
                expect (sort (lsta)).to.equal (lstb)
            })
            test.it ('should correctly sort a List of functions', lambda () {
                class Foo {
                    func a () => null
                    func b () => null
                    func c () => null
                    func d () => null
                }
                lsta = [Foo.b, Foo.d, Foo.a, Foo.c]
                lstb = [Foo.a, Foo.b, Foo.c, Foo.d]
                expect (sort (lsta)).to.equal (lstb)
            })
        })

        # builtin.id repr
        test.describe ('repr', lambda (test) {
            test.it ('should work with strings', lambda () {
                expect (repr ('hello')).to.equal ('"hello"')
            })
            test.it ('should work with integers', lambda () {
                expect (repr (1234)).to.equal ('1234')
                expect (repr (0xFFFFFFFFFFFFFFFFL)).to.equal ('18446744073709551615')
            })
            test.it ('should work with tuples', lambda () {
                expect (repr ((1, 2, 3, 4))).to.equal ('(1, 2, 3, 4)')
                expect (repr (("a", "b", "c"))).to.equal ('("a", "b", "c")')
            })
            test.it ('should work with dictionaries', lambda () {
                expect (repr ({ "a": 1, "b": 2 })).to.equal ('{"b" = 2, "a" = 1}');
            })
            test.it ('should work with lists', lambda () {
                expect (repr ([1, 2, 3, 4])).to.equal ('[1, 2, 3, 4]')
                expect (repr ([null, null, null])).to.equal ('[null, null, null]')
            })
            test.it ('should work with collections', lambda () {
                expect (repr (Array (items: [1, 2, 3, 4]))).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should work with null', lambda () {
                expect (repr (null)).to.equal ('null')
            })
            test.it ('should work with functions', lambda () {
                class Foo {
                    func foo () => null
                }
                expect (repr (Foo.foo)).to.equal ('foo')
            })
        })

        # builtin.id type
        test.describe ('type', lambda (test) {
            test.it ('should return the correct type', lambda () {
                expect (type (Str)).to.equal (Str.__type__)
                expect (type (type)).to.equal (type.__type__)
                expect (type (null)).to.equal (null.__type__)
                expect (type ('test')).to.equal ('test'.__type__)
            })
        })

        # builtin.id range
        test.describe ('range', lambda (test) {
            test.it ('should work with one argument', lambda () {
                expect (List (range (1))).to.equal ([0])
                expect (List (range (2))).to.equal ([0, 1])
            })
            test.it ('should work with two arguments', lambda () {
                expect (List (range (0, 5))).to.equal ([0, 1, 2, 3, 4])
                expect (List (range (1, 6))).to.equal ([1, 2, 3, 4, 5])
            })
            test.it ('should work with three arguments', lambda () {
                expect (List (range (0, 10, 2))).to.equal ([0, 2, 4, 6, 8])
                expect (List (range (1, 10, 2))).to.equal ([1, 3, 5, 7, 9])
            })
            test.it ('should yield the same values as the range operator', lambda () {
                expect (List (range (10))).to.equal (List (0 .. 10))
                expect (List (range (0, 10))).to.equal (List (0 .. 10))
                expect (List (range (0, 11))).to.equal (List (0 ... 10))
                expect (List (range (-10, 11))).to.equal (List (-10 ... 10))
            })
        })

        # builtin.id len
        test.describe ('len', lambda (test) {
            test.it ('should work with collections', lambda () {
                expect (len (Set  ())).to.equal (0)
                expect (len (Array (items: [1, 2, 3, 4]))).to.equal (4)
                expect (len (Stack (items: [1, 2, 3, 4]))).to.equal (4)
            })
            test.it ('should work with iterables', lambda () {
                expect (len (List ())).to.equal (0)
                expect (len ([1, 2, 3, 4])).to.equal (4)
            })
            test.it ('should work with generators', lambda () {
                func generatorTest () {
                    yield 1;
                    yield 2;
                    yield 3;
                }
                expect (len (generatorTest ())).to.equal (3)
            })
        })

        # builtin.id typecast
        test.describe ('typecast', lambda (test) {
            test.it ('should work with all types', lambda () {
                arr = Array ()
                expect (typecast (Int, 1234)).to.equal (1234)
                expect (typecast (Str, "hello")).to.equal ("hello")
                expect (typecast (Null, null)).to.equal (null)
                expect (typecast (Array, arr)).to.equal (arr)
            })
        })

        # builtin.id intcast
        test.describe ('intcast', lambda (test) {
            test.it ('should work with Int literals', lambda () {
                expect (intcast (0)).to.equal (0)
                expect (intcast (1337)).to.equal (1337)
            })
            test.it ('should work with BigInt literals', lambda () {
                expect (intcast (0L)).to.equal (0L)
                expect (intcast (0xFFFFFFFFFFFFFFFFL)).to.equal (0xFFFFFFFFFFFFFFFFL)
            })
        })

        # builtin.id hex
        test.describe ('hex', lambda (test) {
            test.it ('should produce the correct hex string', lambda () {
                expect (hex ([255], prefix: true)).to.equal ("0xff")
                expect (hex ([170, 187, 204, 221, 238, 255])).to.equal ("aabbccddeeff")
            })
        })
    })
    
    # collections.id
    test.describe ('collections', lambda (test) {
        if (!stdlib_isdefined ('collections')) {
            use * from std.collections
        }

        # collections.id Array
        test.describe ('Array', lambda (test) {
            test.it ('should correctly preallocate space', lambda () {
                expect (len (Array (capacity: 0))).to.equal (0)
                expect (len (Array (capacity: 100))).to.equal (100)
            })
            test.it ('should correctly prefill itself', lambda () {
                expect (List (Array (items: [1, 2, 3, 4]))).to.equal ([1, 2, 3, 4])
            })
            test.it ('should correctly count its items', lambda () {
                expect (Array (items: [1, 2, 3, 4]).count ()).to.equal (4)
            })
            test.it ('should correctly clear its items', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                arr.clear ()
                expect (len (arr)).to.equal (0)
            })
            test.it ('should correctly report whether it is empty', lambda () {
                expect (Array ().empty ()).to.be._true ()
                expect (Array (items: [1, 2, 3, 4]).empty ()).to.be._false ()
            })
            test.it ('should correctly add items to itself', lambda () {
                arr = Array ()
                arr.add (1)
                arr.add (2)
                expect (List (arr)).to.equal ([1, 2])
            })
            test.it ('should correctly remove items from itself', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                arr.remove (1)
                arr.remove (3)
                expect (List (arr)).to.equal ([2, 4])
                arr = Array (items: [1, 2, 3, 4])
                arr.removeat (1)
                arr.removeat (2)
                expect (List (arr)).to.equal ([1, 3])
            })
            test.it ('should correctly report whether it contains an item', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr.contains (2)).to.be._true ()
                expect (arr.contains (5)).to.be._false ()
            })
            test.it ('should correctly fill itself with items', lambda () {
                arr = Array (capacity: 5)
                expect (List (arr.fill (0))).to.equal ([0, 0, 0, 0, 0])
                expect (List (arr.fill ('a'))).to.equal (['a', 'a', 'a', 'a', 'a'])
            })
            test.it ('should correctly fill part of itself with items', lambda () {
                arr = Array (items: ['a', 'b', 'b'])
                expect (List (arr.fillrange (2, 1, 'c'))).to.equal (['a', 'b', 'c'])
                arr = Array (items: ['0', '1', '1', '0'])
                expect (List (arr.fillrange (1, 2, '0'))).to.equal (['0', '0', '0', '0'])
            })
            test.it ('should correctly report its length', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr.__len__ ()).to.equal (4)
            })
            test.it ('should correctly override its string representation', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr.__str__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly report its string representation', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr.__repr__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly return items by index', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr [0]).to.equal (1)
                expect (arr [3]).to.equal (4)
            })
            test.it ('should correctly set items by index', lambda () {
                arr = Array (items: [1, 0, 0, 4])
                arr [1] = 2
                arr [2] = 3
                expect (List (arr)).to.equal ([1, 2, 3, 4])
            })
            test.it ('should be iterable', lambda () {
                arr = Array (items: [1, 2, 3, 4])
                expect (arr is Iterable).to.be._true ()
                lst = [1, 2, 3, 4]
                i = 0
                for (item in arr) {
                    expect (item).to.equal (lst [i])
                    i += 1
                }
            })
        })
        
        # collections.id Set
        test.describe ('Set', lambda (test) {
            test.it ('should correctly prefill itself', lambda () {
                expect (List (Set (items: [1, 2, 3, 4]))).to.equal ([1, 2, 3, 4])
            })
            test.it ('should correctly clear its items', lambda () {
                set = Set (items: [1, 2, 3, 4])
                set.clear ()
                expect (len (set)).to.equal (0)
            })
            test.it ('should correctly count its items', lambda () {
                expect (Set (items: [1, 2, 3, 4]).count ()).to.equal (4)
            })
            test.it ('should correctly report whether it is empty', lambda () {
                expect (Set ().empty ()).to.be._true ()
                expect (Set (items: [1, 2, 3, 4]).empty ()).to.be._false ()
            })
            test.it ('should correctly add items to itself', lambda () {
                set = Set ()
                set.add (1)
                set.add (2)
                expect (List (set)).to.equal ([1, 2])
            })
            test.it ('should correctly remove items from itself', lambda () {
                set = Set (items: [1, 2, 3, 4])
                set.remove (1)
                set.remove (3)
                expect (List (set)).to.equal ([2, 4])
            })
            test.it ('should correctly calculate the union', lambda () {
                set1 = Set (items: [1, 2])
                set2 = Set (items: [3, 4])
                expect (List (set1.union (set2))).to.equal ([3, 4, 1, 2])
            })
            test.it ('should correctly calculate the intersection', lambda () {
                set1 = Set (items: [1, 2, 3, 4])
                set2 = Set (items: [3, 4, 5, 6])
                expect (List (set1.intersection (set2))).to.equal ([3, 4])
            })
            test.it ('should correctly calculate the difference', lambda () {
                set1 = Set (items: [2, 4, 6, 8])
                set2 = Set (items: [1, 4, 5, 8])
                expect (List (set1.difference (set2))).to.equal ([2, 6])
                expect (List (set2.difference (set1))).to.equal ([1, 5])
            })
            test.it ('should correctly determine whether it is a superset', lambda () {
                set1 = Set (items: [1, 2, 3, 4, 5, 6, 7, 8, 9])
                set2 = Set (items: [   2,    4,    6,    8   ])
                expect (set1.superset (set2)).to.be._true ()
                expect (set2.superset (set1)).to.be._false ()
            })
            test.it ('should correctly determine whether it is a subset', lambda () {
                set1 = Set (items: [   2,    4,    6,    8   ])
                set2 = Set (items: [1, 2, 3, 4, 5, 6, 7, 8, 9])
                expect (set1.subset (set2)).to.be._true ()
                expect (set2.subset (set1)).to.be._false ()
            })
            test.it ('should correctly report whether it contains an item', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set.contains (2)).to.be._true ()
                expect (set.contains (5)).to.be._false ()
            })
            test.it ('should correctly report its length', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set.__len__ ()).to.equal (4)
            })
            test.it ('should correctly override its string representation', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set.__str__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly report its string representation', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set.__repr__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly return items by index', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set [0]).to.equal (1)
                expect (set [3]).to.equal (4)
            })
            test.it ('should be iterable', lambda () {
                set = Set (items: [1, 2, 3, 4])
                expect (set is Iterable).to.be._true ()
                lst = [1, 2, 3, 4]
                i = 0
                for (item in set) {
                    expect (item).to.equal (lst [i])
                    i += 1
                }
            })
        })
        
        # collections.id GenericSet
        test.describe ('GenericSet', lambda (test) {
            test.it ('should correctly infer the type', lambda () {
                set = GenericSet ()
                set.add (1)
                set.add (2)
                expect (set.type).to.equal (Int)
            })
            test.it ('should not accept other types', lambda () {
                set = GenericSet ()
                set.add (0)
                raised = false
                try {
                    set.add ('a')
                } except {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should accept its type as keyword argument', lambda () {
                # Compiler bug: super (kwargs) consumes the **kwargs
                #set = GenericSet (T: Str)
                #set.add ('a')
                #set.add ('b')
                #set.add ('c')
            })
        })

        # collections.id Stack
        test.describe ('Stack', lambda (test) {
            test.it ('should correctly prefill itself', lambda () {
                expect (List (Stack (items: [1, 2, 3, 4]))).to.equal ([4, 3, 2, 1])
            })
            test.it ('should correctly clear its items', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                stack.clear ()
                expect (len (stack)).to.equal (0)
            })
            test.it ('should correctly count its items', lambda () {
                expect (Stack (items: [1, 2, 3, 4]).count ()).to.equal (4)
            })
            test.it ('should correctly report whether it is empty', lambda () {
                expect (Stack ().empty ()).to.be._true ()
                expect (Stack (items: [1, 2, 3, 4]).empty ()).to.be._false ()
            })
            test.it ('should raise if items are added using Stack.add', lambda () {
                stack = Stack ()
                raised = false
                try {
                    stack.add (1)
                    stack.add (2)
                } except {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should correctly push items onto itself', lambda () {
                stack = Stack ()
                stack.push (1)
                stack.push (2)
                expect (List (stack)).to.equal ([2, 1])
            })
            test.it ('should correctly pop items from itself', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                stack.pop ()
                stack.pop ()
                expect (List (stack)).to.equal ([2, 1])
            })
            test.it ('should correctly remove items from itself', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                stack.remove (1)
                stack.remove (3)
                expect (List (stack)).to.equal ([4, 2])
                stack = Stack (items: [1, 2, 3, 4])
                stack.removeat (0)
                stack.removeat (0)
                expect(List (stack)).to.equal ([2, 1])
            })
            test.it ('should correctly report whether it contains an item', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack.contains (2)).to.be._true ()
                expect (stack.contains (5)).to.be._false ()
            })
            test.it ('should correctly report its length', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack.__len__ ()).to.equal (4)
            })
            test.it ('should correctly override its string representation', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack.__str__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly report its string representation', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack.__repr__ ()).to.equal ('[1, 2, 3, 4]')
            })
            test.it ('should correctly return items by index', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack [0]).to.equal (4)
                expect (stack [3]).to.equal (1)
            })
            test.it ('should correctly set items by index', lambda () {
                stack = Stack (items: [1, 0, 0, 4])
                stack [1] = 3
                stack [2] = 2
                expect (List (stack)).to.equal ([4, 3, 2, 1])
            })
            test.it ('should be iterable', lambda () {
                stack = Stack (items: [1, 2, 3, 4])
                expect (stack is Iterable).to.be._true ()
                lst = [4, 3, 2, 1]
                i = 0
                for (item in stack) {
                    expect (item).to.equal (lst [i])
                    i += 1
                }
            })
        })

        # collections.id GenericStack
        test.describe ('GenericStack', lambda (test) {
            test.it ('should correctly infer the type', lambda () {
                stack = GenericStack ()
                stack.push (1)
                stack.push (2)
                expect (stack.type).to.equal (Int)
            })
            test.it ('should not accept other types', lambda () {
                stack = GenericStack ()
                stack.push (0)
                raised = false
                try {
                    stack.push ('a')
                } except {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should accept its type as keyword argument', lambda () {
                # Compiler bug: super (kwargs) consumes the **kwargs
                #stack = GenericStack (T: Str)
                #stack.add ('a')
                #stack.add ('b')
                #stack.add ('c')
            })
        })
    })
    
    # exceptions.id
    test.describe ('exceptions', lambda (test) {
        if (!stdlib_isdefined ('exceptions')) {
            use * from std.exceptions
        }

        # exceptions.id ArgumentException
        test.describe ('ArgumentException', lambda (test) {
            test.it ('should raise', lambda () {
                raised = false
                try {
                    raise ArgumentException ('x', 'test')
                } except (e as ArgumentException) {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should have the right message', lambda () {
                try {
                    raise ArgumentException ('x', 'test')
                } except (e as ArgumentException) {
                    expect (e.message).to.equal ("Argument 'x': test")
                    return;
                }
                fail ('should have raised')
            })
        })

        # exceptions.id TypeException
        test.describe ('TypeException', lambda (test) {
            test.it ('should raise', lambda () {
                raised = false
                try {
                    raise TypeException ('x', 'Str|Int')
                } except (e as TypeException) {
                    raised = true
                }
                if (!raised) {
                    fail ('should have raised')
                }
            })
            test.it ('should have the right message', lambda () {
                try {
                    raise TypeException ('x', 'Str|Int')
                } except (e as TypeException) {
                    expect (e.message).to.equal ("Expected 'x' to be of type Str or Int")
                    return;
                }
                fail ('should have raised')
            })
        })
    })

    # functools.id
    test.describe ('functools', lambda (test) {
        if (!stdlib_isdefined ('functools')) {
            use * from std.functools
        }

        # functools.id memoize
        test.describe ('memoize', lambda (test) {
            test.it ('should correctly cache values', lambda () {
                @memoize
                func fib (n) {
                    if (n < 2) {
                        return n
                    }
                    return fib (n - 2) + fib (n - 1)
                }
                fib (31)
                ckeys = [1, 0]
                ckeys.appendrange (List (2 .. 32))
                cvals = [
                    0000001, 0000000, 0000001, 0000002,
                    0000003, 0000005, 0000008, 0000013,
                    0000021, 0000034, 0000055, 0000089,
                    0000144, 0000233, 0000377, 0000610,
                    0000987, 0001597, 0002584, 0004181,
                    0006765, 0010946, 0017711, 0028657,
                    0046368, 0075025, 0121393, 0196418,
                    0317811, 0514229, 0832040, 1346269
                ]
                i = 0
                for (key, value in fib.cache) {
                    expect (key [0]).to.equal (ckeys [i])
                    expect (value).to.equal (cvals [i])
                    i += 1
                }
            })
        })
    })

    # ints.id
    test.describe ('ints', lambda (test) {
        if (!stdlib_isdefined ('ints')) {
            use * from std.ints
        }

        # ints.id int8
        test.it ('should correctly cast signed bytes', lambda () {
            div = 0x7F
            dix = div + 0x1
            max = dix * 0x20
            for (i in range (0, max, pow (2, 10))) {
                expect (int8 (i)).to.equal (i % dix)
            }
        })

        # ints.id uint8
        test.it ('should correctly cast unsigned bytes', lambda () {
            div = 0xFF
            dix = div + 0x1
            max = dix * 0x20
            for (i in range (0, max, pow (2, 10))) {
                expect (uint8 (i)).to.equal (i % dix)
            }
        })

        # ints.id int16
        test.it ('should correctly cast signed halfwords', lambda () {
            div = 0x7FFF
            dix = div + 0x1
            max = dix * 0x8
            for (i in range (0, max, pow (2, 10 + 0x2))) {
                expect (int16 (i)).to.equal (i % dix)
            }
        })

        # ints.id uint16
        test.it ('should correctly cast unsigned halfwords', lambda () {
            div = 0xFFFF
            dix = div + 0x1
            max = dix * 0x8
            for (i in range (0, max, pow (2, 10 + 0x4))) {
                expect (uint16 (i)).to.equal (i % dix)
            }
        })

        # ints.id int32
        test.it ('should correctly cast signed words', lambda () {
            div = 0x7FFFFFFF
            dix = div + 0x1
            max = dix * 0x4
            for (i in range (0, max, pow (2, 10 + 0x10))) {
                expect (int32 (i)).to.equal (i % dix)
            }
        })

        # ints.id uint32
        test.it ('should correctly cast unsigned words', lambda () {
            div = 0xFFFFFFFF
            dix = div + 0x1
            max = dix * 0x4
            for (i in range (0, max, pow (2, 10 + 0x10))) {
                expect (uint32 (i)).to.equal (i % dix)
            }
        })

        # ints.id int64
        test.it ('should correctly cast signed qwords', lambda () {
            dix = 0x8000000000000000L
            max = dix * 0x2
            for (i in range (0, max, bigpow (2, 10 + 0x30))) {
                result = int64 (i)
                expect (result).to.equal (i % dix)
            }
        })
    })

    # itertools.id
    test.describe ('itertools', lambda (test) {
        if (!stdlib_isdefined ('itertools')) {
            use * from std.itertools
        }

        # itertools.id any
        test.describe ('any', lambda (test) {
            test.it ('should work with empty iterables', lambda () {
                expect (any (List ())).to.be._false ()
            })
            test.it ('should work with non-empty iterables', lambda () {
                expect (any ([1, 2, 3, 4])).to.be._true ()
            })
            test.it ('should work with empty iterables and conditions', lambda () {
                expect (any (List (), lambda (i) => 0)).to.be._false ()
            })
            test.it ('should work with non-empty iterables and conditions', lambda () {
                expect (any ([0, 1, 2, 3], lambda (i) => i == 0)).to.be._true ()
            })
        })

        # itertools.id chain
        test.describe ('chain', lambda (test) {
            test.it ('should correctly combine iterables', lambda () {
                itera = [1, 2, 3]
                iterb = [4, 5, 6]
                expect (List (chain (itera, iterb))).to.equal ([1, 2, 3, 4, 5, 6])
            })
        })

        # itertools.id each
        test.describe ('each', lambda (test) {
            test.it ('should correctly imitate \'for\' behavior', lambda () {
                itera = [1, 2, 3, 4]
                sum = 0
                each (itera, lambda (i) => sum += i)
                expect (sum).to.equal (10)
            })
        })

        # itertools.id take
        test.describe ('take', lambda (test) {
            test.it ('should yield the correct elements', lambda () {
                itera = [1, 2, 3, 4]
                iterb = take (itera, 2)
                expect (List (iterb)).to.equal ([1, 2])
            })
        })

        # itertools.id takewhile
        test.describe ('takeWhile', lambda (test) {
            test.it ('should yield the correct elements', lambda () {
                itera = [1, 2, 3, 4]
                iterb = takewhile (itera, lambda (i) => i <= 2)
                expect (List (iterb)).to.equal ([1, 2])
            })
        })

        # itertools.id skip
        test.describe ('skip', lambda (test) {
            test.it ('should yield the correct elements', lambda () {
                itera = [1, 2, 3, 4]
                iterb = skip (itera, 2)
                expect (List (iterb)).to.equal ([3, 4])
            })
        })

        # itertools.id skipwhile
        test.describe ('skipwhile', lambda (test) {
            test.it ('should yield the correct elements', lambda () {
                itera = [1, 2, 3, 4]
                iterb = skipwhile (itera, lambda (i) => i <= 2)
                expect (List (iterb)).to.equal ([3, 4])
            })
        })

        # itertools.id sum
        test.describe ('sum', lambda (test) {
            test.it ('should correctly sum up iterables', lambda () {
                itera = [1, 2, 3, 4]
                expect (sum (itera)).to.equal (10)
            })
        })

        # itertools.id zip
        test.describe ('zip', lambda (test) {
            test.it ('should correctly zip iterables together', lambda () {
                itera = [1, 2]
                iterb = [3, 4]
                iterc = zip (itera, iterb)
                print (repr (iterc))
                lst = [(1, 3), (2, 4)]
                i = 0
                for (tpl in iterc) {
                    print ("a: #{repr (lst [i])}; b: #{repr (tpl)}")
                    expect (tpl).to.equal (lst [i])
                    i += 1
                }
            })
        })

        # itertools.id reduce
        test.describe ('reduce', lambda (test) {
            test.it ('should correctly reduce iterables', lambda () {
                itera = [1, 2, 3, 4]
                sum = reduce (itera, lambda (i, j) => i + j)
                expect (sum).to.equal (10)
            })
        })

        # itertools.id filter
        test.describe ('filter', lambda (test) {
            test.it ('should correctly filter iterables', lambda () {
                itera = [0, 1, 2, 3]
                iterb = filter (itera, lambda (i) => i % 2 == 0)
                expect (List (iterb)).to.equal ([0, 2])
            })
        })

        # itertools.id map
        test.describe ('map', lambda (test) {
            test.it ('should correctly map iterables', lambda () {
                itera = [0, 1, 2, 3]
                iterb = map (itera, lambda (i) => i % 2)
                expect (List (iterb)).to.equal ([0, 1, 0, 1])
            })
        })
    })

    # math.id
    test.describe ('math', lambda (test) {
        if (!stdlib_isdefined ('math')) {
            use * from std.math
        }

        # math.id fibonacci
        test.describe ('fibonacci', lambda (test) {
            test.it ('naive algorithm', lambda () {
                lst = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
                for (i in range (1, 11)) {
                    expect (fibonacci (i, method: 'naive')).to.equal (lst [i - 1])
                }
            })
            test.it ('fastdoubling algorithm', lambda () {
                lst = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
                for (i in range (1, 11)) {
                    expect (fibonacci (i, method: 'fastdoubling')).to.equal (lst [i - 1])
                }
            })
        })

        # math.id factorial
        test.describe ('factorial', lambda (test) {
            test.it ('naive algorithm', lambda () {
                lst = [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
                for (i in range (1, 11)) {
                    expect (factorial (i, method: 'naive')).to.equal (lst [i - 1])
                }
            })
            test.it ('stirling approximation', lambda () {
                lst = [1, 2, 6, 24, 120, 720]
                for (i in range (1, 7)) {
                    expect (factorial (i, method: 'stirling')).to.equal (lst [i - 1])
                }
            })
        })

        # math.id exp
        test.describe ('exp', lambda (test) {
            test.it ('default algorithm', lambda () {
                /*
                 * Float comparison too inaccurate:
                 * Probably a compiler bug.
                 * The results seem to be valid
                 */
                /*
                lst = [
                    2.718281828459045,
                    7.38905609893065,
                    20.085536923187668,
                    54.598150033144236,
                    148.4131591025766,
                    403.4287934927351,
                    1096.6331584284585,
                    2980.9579870417283,
                    8103.083927575384,
                    22026.465794806718
                ]
                epsilon = 0.0000000000000000001
                for (i in range (1, 11)) {
                    expect (exp (i)).to.equal (lst [i - 1])
                }
                */
            })
        })

        # math.id bigpow
        test.describe ('bigpow', lambda (test) {
            test.it ('should compute the correct value', lambda () {
                lst = [2L, 4L, 8L, 16L, 32L, 64L, 128L, 256L, 512L, 1024L]
                for (i in range (1, 11)) {
                    expect (bigpow (2, i)).to.equal (lst [i - 1])
                    expect (bigpow (2L, i)).to.equal (lst [i - 1])
                }
            })
        })

        # math.id pow
        test.describe ('pow', lambda (test) {
            test.it ('should accept Ints and compute the correct values', lambda () {
                lst = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
                for (i in range (1, 11)) {
                    expect (pow (2, i)).to.equal (lst [i - 1])
                }
            })
            test.it ('should accept Floats and compute the correct values', lambda () {
                lsta = [2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0]
                for (i in range (1, 11)) {
                    expect (pow (2.0, i)).to.equal (lsta [i - 1])
                }
                /*
                 * Float comparison too inaccurate
                 * The results seem to be valid
                 */
                /*
                lstb = [
                    2.1, 4.41, 9.261,
                    19.4481, 40.84101,
                    85.766121, 180.1088541,
                    378.22859361, 794.280046581,
                    1667.9880978201
                ]
                for (i in range (1, 11)) {
                    expect (pow (2.1, i)).to.equal (lstb [i - 1])
                }
                */
            })
            test.it ('should call bigpow if supplied with a BigInt', lambda () {
                lst = [2L, 4L, 8L, 16L, 32L, 64L, 128L, 256L, 512L, 1024L]
                for (i in range (1, 11)) {
                    expect (pow (2L, i)).to.equal (lst [i - 1])
                }
            })
            test.it ('intpow algorithm', lambda () {
                lst = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
                for (i in range (1, 11)) {
                    expect (pow (2, i, method: 'intpow')).to.equal (lst [i - 1])
                }
            })
            test.it ('altpow algorithm', lambda () {
                lst = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
                for (i in range (1, 11)) {
                    expect (pow (2, i, method: 'altpow')).to.equal (lst [i - 1])
                }
            })
            test.it ('floatpow algorithm', lambda () {
                /*
                 * Float comparison is completely fucked.
                 */
                /*
                lst = [2L, 4L, 8L, 16L, 32L, 64L, 128L, 256L, 512L, 1024L]
                for (i in range (1, 11)) {
                    expect (pow (2, i, method: 'floatpow')).to.equal (lst [i - 1])
                }
                */
            })
            test.it ('shiftpow algorithm', lambda () {
                lst = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
                for (i in range (1, 11)) {
                    expect (pow (2, i, method: 'shiftpow')).to.equal (lst [i - 1])
                }
            })
            test.it ('fastpow algorithm', lambda () {
                lst = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
                for (i in range (1, 11)) {
                    expect (pow (2, i, method: 'fastpow')).to.equal (lst [i - 1])
                }
            })
        })

        # math.id sqrt
        test.describe ('sqrt', lambda (test) {
            test.it ('should compute the correct value', lambda () {
                dct = {1: 1, 4: 2, 9: 3, 16: 4,25: 5, 36: 6}
                for (key, value in dct) {
                    val = Int (sqrt (key))
                    expect (val).to.equal (value)
                }
            })
            test.it ('babylonian algorithm', lambda () {
                dct = {1: 1, 4: 2, 9: 3, 16: 4,25: 5, 36: 6}
                for (key, value in dct) {
                    val = Int (sqrt (key, method: 'babylonian'))
                    expect (val).to.equal (value)
                }
            })
            test.it ('babylonian2 algorithm', lambda () {
                dct = {1: 1, 4: 2, 9: 3, 16: 4,25: 5, 36: 6}
                for (key, value in dct) {
                    val = Int (sqrt (key, method: 'babylonian2'))
                    expect (val).to.equal (value)
                }
            })
            test.it ('bakhsali algorithm', lambda () {
                dct = {1: 1, 4: 2, 9: 3, 16: 4,25: 5, 36: 6}
                for (key, value in dct) {
                    val = Int (sqrt (key, method: 'bakhsali'))
                    expect (val).to.equal (value)
                }
            })
            test.it ('newtons algorithm (high precision)', lambda () {
                dct = {1: 1, 4: 2, 9: 3, 16: 4,25: 5, 36: 6}
                for (key, value in dct) {
                    val = Int (sqrt (key, method: 'newtons', precision: 15))
                    expect (val).to.equal (value)
                }
            })
            test.it ('newtons2 algorithm (high precision)', lambda () {
                dct = {1: 1, 4: 2, 9: 3, 16: 4,25: 5, 36: 6}
                for (key, value in dct) {
                    val = Int (sqrt (key, method: 'newtons2', precision: 15))
                    expect (val).to.equal (value)
                }
            })
        })

        # math.id sin
        test.describe ('sin', lambda (test) {
            /*
             * Unable to test sin
             * Float comparison is broken
             */
        })

        # math.id cos
        test.describe ('cos', lambda (test) {
            /*
             * Unable to test cos
             * Float comparison is broken
             */
        })

        # math.id min
        test.describe ('min', lambda (test) {
            test.it ('should work with positive values', lambda () {
                expect (min (1, 10)).to.equal (1)
            })
            test.it ('should work with negative values', lambda () {
                expect (min (-1, -10)).to.equal (-10)
            })
        })

        # math.id max
        test.describe ('max', lambda (test) {
            test.it ('should work with positive values', lambda () {
                expect (max (1, 10)).to.equal (10)
            })
            test.it ('should work with negative values', lambda () {
                expect (max (-1, -10)).to.equal (-1)
            })
        })

        # math.id floor
        test.describe ('floor', lambda (test) {
            test.it ('should work with positive values', lambda () {
                expect (floor (0.99999999)).to.equal (0)
            })
        })

        # math.id abs
        test.describe ('abs', lambda (test) {
            test.it ('should work with positive Ints', lambda () {
                expect (abs (100)).to.equal (100)
            })
            test.it ('should work with negative Ints', lambda () {
                expect (abs (-100)).to.equal (100)
            })
            test.it ('should work with positive Floats', lambda () {
                expect (abs (10.10)).to.equal (10.10)
            })
            test.it ('should work with negative Floats', lambda () {
                expect (abs (-10.10)).to.equal (10.10)
            })
        })
    })
    
    # reflection.id
    test.describe ('reflection', lambda (test) {
        if (!stdlib_isdefined ('reflection')) {
            use * from std.reflection
        }

        # reflection.id typedef
        test.describe ('typedef', lambda (test) {
            test.it ('should work with builtin type definitions', lambda () {
                expect (typedef (Int)).to.be._true ()
                expect (typedef (Str)).to.be._true ()
                expect (typedef (Null)).to.be._true ()
            })
            test.it ('should work with custom type definitions', lambda () {
                class Foo { }
                expect (typedef (Foo)).to.be._true ()
            })
            test.it ('should work with builtin instances', lambda () {
                expect (typedef (0)).to.be._false ()
                expect (typedef ('')).to.be._false ()
                expect (typedef (null)).to.be._false ()
            })
            test.it ('should work with custom instances', lambda () {
                class Foo { }
                expect (typedef (Foo ())).to.be._false ()
            })
        })

        # reflection.id instance
        test.describe ('instance', lambda (test) {
            test.it ('should work with builtin type definitions', lambda () {
                expect (instance (Int)).to.be._false ()
                expect (instance (Str)).to.be._false ()
                expect (instance (Null)).to.be._false ()
            })
            test.it ('should work with custom type definitions', lambda () {
                class Foo { }
                expect (instance (Foo)).to.be._false ()
            })
            test.it ('should work with builtin instances', lambda () {
                expect (instance (0)).to.be._true ()
                expect (instance ('')).to.be._true ()
                expect (instance (null)).to.be._true ()
            })
            test.it ('should work with custom instances', lambda () {
                class Foo { }
                expect (instance (Foo ())).to.be._true ()
            })
        })

        # reflection.id instanceof
        test.describe ('instanceof', lambda (test) {
            test.it ('should work with builtin types/types', lambda () {
                expect (instanceof (Int, Int)).to.be._false ()
                expect (instanceof (Str, Str)).to.be._false ()
                expect (instanceof (Null, Null)).to.be._false ()
                expect (instanceof (Int, Str)).to.be._false ()
                expect (instanceof (Str, Null)).to.be._false ()
                expect (instanceof (Null, Int)).to.be._false ()
            })
            test.it ('should work with builtin types/instances', lambda () {
                expect (instanceof (Int, 0)).to.be._true ()
                expect (instanceof (Str, '')).to.be._true ()
                expect (instanceof (Null, null)).to.be._true ()
            })
            test.it ('should work with builtin instances/instances', lambda () {
                expect (instanceof (0, 0)).to.be._false ()
                expect (instanceof ('', '')).to.be._false ()
                expect (instanceof (null, null)).to.be._false ()
                expect (instanceof (0, '')).to.be._false ()
                expect (instanceof ('', null)).to.be._false ()
                expect (instanceof (null, 0)).to.be._false ()
            })
            test.it ('should work with custom types/types', lambda () {
                class Foo { }
                expect (instanceof (Foo, Foo)).to.be._false ()
            })
            test.it ('should work with custom types/instances', lambda () {
                class Foo { }
                expect (instanceof (Foo, Foo ())).to.be._true ()
            })
            test.it ('should work with custom instances/instances', lambda () {
                class Foo { }
                expect (instanceof (Foo (), Foo ())).to.be._false ()
            })
        })

        # reflection.id nameof
        test.describe ('nameof', lambda (test) {
            test.it ('should work with builtin types', lambda () {
                expect (nameof (Int)).to.equal ('Int')
                # Probably a compiler bug:
                # expect (nameof (Str)).to.equal ('Str')
            })
            test.it ('should work with builtin instances', lambda () {
                expect (nameof (0)).to.equal ('Int')
                # Probably a compiler bug:
                # expect (nameof ('')).to.equal ('Str')
            })
            test.it ('should work with custom types', lambda () {
                class Foo { }
                expect (nameof (Foo)).to.equal ('Foo')
            })
            test.it ('should work wih custom instances', lambda () {
                class Foo { }
                expect (nameof (Foo ())).to.equal ('Foo')
            })
            test.it ('should work with functions', lambda () {
                class Foo {
                    func foo () { }
                }
                expect (nameof (Foo.foo)).to.equal ('foo')
            })
            test.it ('should work with closures', lambda () {
                foo = lambda () { }
                expect (nameof (foo)).to.equal ('Closure')
            })
        })
    })
    
    # tupletools.id
    test.describe ('tupletools', lambda (test) {

        # tupletools.id fst
        test.describe ('fst', lambda (test) {
            test.it ('should return the correct value', lambda () {
                tpl = (1, 2)
                expect (fst (tpl)).to.equal (1)
            })
        })

        # tupletools.id snd
        test.describe ('snd', lambda (test) {
            test.it ('should return the correct value', lambda () {
                tpl = (1, 2)
                expect (snd (tpl)).to.equal (2)
            })
        })

        # tupletools.id nth
        test.describe ('nth', lambda (test) {
            test.it ('should return the correct value', lambda () {
                tpl = (1, 2, 3)
                expect (nth (tpl, 3)).to.equal (3)
            })
        })
    })

    # types.id
    test.describe ('types', lambda (test) {
        test.it ('should define the correct types', lambda () {
            expect (NullType).to.equal (Null)
            expect (ObjectType).to.equal (Object)
            expect (IntType).to.equal (Int)
            expect (FloatType).to.equal (Float)
            expect (BooleanType).to.equal (Bool)
            expect (StringType).to.equal (Str)
            expect (TupleType).to.equal (Tuple)
            expect (ListType).to.equal (List)
            expect (DictType).to.equal (Dict)
            expect (ExceptionType).to.equal (Exception)
        })
    })
})
tracer_report ()